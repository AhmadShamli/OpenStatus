#!/usr/bin/python

import socket, signal, os, sys, atexit, time, getopt, sqlite3, smtplib, logging, asyncore
from configobj import ConfigObj, ConfigObjError
from validate import Validator
from time import time

logger = logging.getLogger('openstatus-server')
hdlr = logging.FileHandler('/var/log/openstatus-server.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr) 
logger.setLevel(logging.INFO)
ch  = logging.StreamHandler()
logger.addHandler(ch)

try:
	import setproctitle
	setproctitle.setproctitle('openstatus-server')
except ImportError:
	logger.warning('setproctitle not found')
try:       
	import json
except:
	try:     
		import simplejson as json
	except ImportError:
		logger.error('Could not import json module')
		sys.exit(1)

debug = False
configfile = '/etc/openstatus/openstatus-server.conf'
try:
	options, remainder = getopt.getopt(sys.argv[1:], 'dc:', ['debug',])
except getopt.GetoptError:
	print "usage: ",sys.argv[0]," [-c configfile] [-d | --debug]"
	sys.exit(2)

for opt, args in options:
	if opt in ('-d', '--debug'):
		debug = True
	elif opt in ('-c'):
		if args in ('-d', '--debug'):
			print "usage: ", sys.argv[0]," [-c configfile] [-d | --debug]"
			sys.exit(2)
		configfile = args

if debug == True:
	logger.setLevel(logging.DEBUG)

# Let's make this a daemon... this is a very basic daemon fork, taken from: http://code.activestate.com/recipes/66012-fork-a-daemon-process-on-unix/#c9
# Do the first fork
def daemonize(stdout, stderr, stdin, pidfile, startmsg = 'OpenStatus started with pid %s' ):

	try:
		pid = os.fork()
		if pid > 0: sys.exit(0) # Exit first parent.
	except OSError, e:
		logger.error("fork #1 failed: (%d) %s" % (e.errno, e.strerror))
		sys.exit(1)

	# Decouple from parent environment.
	#os.chdir("/") # I don't think this is necessary, and it just breaks relative pathnames with the -c switch
	os.umask(0)
	os.setsid()

	# Do second fork.
	try:
		pid = os.fork()
		if pid > 0: sys.exit(0) # Exit second parent.
	except OSError, e:
		logger.error("fork #2 failed: (%d) %s" % (e.errno, e.strerror))
		sys.exit(1)

	# Open file descriptors and print start message
	if not stderr: stderr = stdout
	si = file(stdin, 'r')
	so = file(stdout, 'a+')
	se = file(stderr, 'a+', 0)
	pid = str(os.getpid())

	logger.info("%s using config file %s" % (startmsg, configfile) % pid)
	if pidfile: file(pidfile,'w+').write("%s" % pid)
	if debug == False:
		logger.removeHandler(ch)
	# Redirect standard file descriptors.
	os.dup2(si.fileno(), sys.stdin.fileno())
	os.dup2(so.fileno(), sys.stdout.fileno())
	os.dup2(se.fileno(), sys.stderr.fileno())

def send_email(sender, receiver, subject, body):

	msg = ("From: %s\rTo: %s\rSubject: %s\r\r%s" %(sender, receiver, subject, body))
	s = smtplib.SMTP('localhost')
	s.sendmail(sender, [receiver], msg)
	s.quit()

def alert(hostname, ip, module, level, value, setstatus = False):

	# Let's insert this alert into the database
	sql.execute('SELECT * FROM servers WHERE hostname = ?', [hostname])
	server = sql.fetchone()

	alertinfo = (server['uid'], module, level, int(time()), value, 0)
	alertcheck = (server['uid'], module, level, int(time()-3600), 0)
	sql.execute('SELECT * FROM alerts WHERE server_uid = ? AND module = ? AND level = ? AND alert_time > ? AND acked = ?', alertcheck)
	alerts = 0
	for row in sql:
		alerts += 1

	if (alerts < 1):
		sql.execute('INSERT INTO alerts (server_uid, module, level, alert_time, value, acked) VALUES (?, ?, ?, ?, ?, ?)', alertinfo)
		if (setstatus == True):
			sql.execute('UPDATE servers SET status = 0 WHERE uid = ?', (server['uid'], ))
		title = "OpenStatus alert on server %s" % hostname
		message = "A problem was detected with a server monitored by OpenStatus.  The details are below. Server: %sModule: %sAlert Level: %sValue: %s" % (hostname, module, level, value)
		send_email(config['server']['email_from'], config['warning']['email'], title, message)

def sigHdl(signum, frm):
	global s
	if signum == signal.SIGTERM:
		logger.critical('Received SIGTERM... Exiting.')
		try:
			s.close()
		except:
			logger.debug('No connection to close')
		os._exit(0)
	else:
		logger.critical('Received signal %s... Exiting.' % (signum))
		try:
			s.close()
		except:
			logger.debug('No connection to close')
		os._exit(0)

def checkServers():

	# Let's check each server in the database to see when we last heard from it.
	sql.execute('SELECT * FROM servers WHERE disabled = 0')
	for row in sql:
		if (row['time'] < (int(time()) - 300)):
			alert(row['hostname'], '0.0.0.0', 'Server Status', 'Critical', 'Down', True)

def getConfig():

	global config, configfile

	cfg = """
	[server]
	listen_ip = ip_addr(default='0.0.0.0')
	port = integer(min=1, max=65535, default=12999)
	email_from = string(default='root@localhost')
	[warning]
	email = string(default='root@localhost')
	[critical]
	email = string(default='root@localhost')
	"""
	try:
		config = ConfigObj(configfile, file_error = True, configspec=cfg.split('\n'), list_values=False)
	except (ConfigObjError, IOError), e:
		logger.error('%s' % (e))
		try:
			configfile = '/etc/openstatus/openstatus-server.conf'
			config = ConfigObj(configfile, file_error = True, configspec=cfg.split(''), list_values=False)
		except (ConfigObjError, IOError), e:
			logger.error('%s' % (e))
			logger.error('Exiting...')
			sys.exit(3)
	validator = Validator()
	result = config.validate(validator)
	if result != True:
		logger.error('Config file validation failed!')
		sys.exit(1)

def dbConnect():

	db = sqlite3.connect('/etc/openstatus/openstatus.db', check_same_thread = False, isolation_level=None)
	db.row_factory=sqlite3.Row
	global sql
	sql = db.cursor()


	

def processData(data):
	global addr
	# This huge block of indented try except else statements could probably be done better
	try: # Make sure it's actually json that got sent
		data = json.loads(data)
	except ValueError:
		logger.error('JSON error from %s' % (addr[0]))
	else:
		logger.debug('Received JSON from %s: %s' % (addr[0], data))
		try: # Check that there's a hostname defined
			host = data['hostname']
		except KeyError:
			logger.error('No hostname in json from %s' % (addr[0]))
		else:
			try: # Let's see if we have a server with this IP
				sql.execute('SELECT * FROM servers WHERE ip = ?', [addr[0]])
			except sqlite3.OperationalError, msg:
				logger.error(msg, "")
			else:
				server = sql.fetchone()
				if (server != None):

					ins = (data['time'], 1, data['uptime']['uptime'], data['ram']['total'], data['ram']['used'], data['ram']['free'], data['ram']['bufcac'], data['disk']['total']['total'], data['disk']['total']['used'], data['disk']['total']['avail'], data['uptime']['load1'], data['uptime']['load5'], data['uptime']['load15'], server['uid'])
					history = (data['time'], data['ram']['total'], data['ram']['used'], data['ram']['free'], data['ram']['bufcac'], data['disk']['total']['total'], data['disk']['total']['used'], data['disk']['total']['avail'], data['uptime']['load1'], data['uptime']['load5'], data['uptime']['load15'], server['uid'])
					sql.execute('UPDATE servers SET time = ?, status = ?, uptime = ?, mtotal = ?, mused = ?, mfree = ?, mbuffers = ?, disktotal = ?, diskused = ?, diskfree = ?, load1 = ?, load5 = ?, load15 = ? WHERE uid = ?', ins)
					logger.debug(history)
					sql.execute('INSERT INTO history (time, mtotal, mused, mfree, mbuffers, disktotal, diskused, diskfree, load1, load5, load15, uid) VALUES( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', history)

					# Let's temporarily set all processes to unknown (-1) status
					sql.execute('UPDATE processes SET status = ? WHERE uid = ?', (-1, server['uid']))
					if "procs" in data:
						for proc in data['procs']:
							upd = (data['procs'][proc]['status'], server['uid'], data['procs'][proc]['name'])
							sql.execute('UPDATE processes SET status = ? WHERE uid = ? AND name = ?', upd)
							if data['procs'][proc]['status'] == 1: alert(server['hostname'], addr, data['procs'][proc]['name'], "Warning", "Down")
							elif data['procs'][proc]['status'] == 2: alert(server['hostname'], addr, data['procs'][proc]['name'], "Critical", "Down")
					if "commands" in data:
						for com in data['commands']:
							# These are handled the same way as process checks because it makes it so much easier, and they're pretty much the same anyways
							upd = (data['commands'][com]['status'], server['uid'], data['commands'][com]['name'])
							sql.execute('UPDATE processes SET status = ? WHERE uid = ? AND name = ?', upd)
							if data['commands'][com]['status'] == 1: alert(server['hostname'], addr, data['commands'][com]['name'], "Warning", data['commands'][com]['value'])
							elif data['commands'][com]['status'] == 2: alert(server['hostname'], addr, data['commands'][com]['name'], "Critical", data['commands'][com]['value'])
					if data['ram']['status'] != 0:
						if data['ram']['status'] == 1: alert(server['hostname'], addr, 'Memory', 'Warning', data['ram']['used'])
						elif data['ram']['status'] == 2: alert(server['hostname'], addr, 'Memory', 'Critical', data['ram']['used'])

					if data['disk']['total']['status'] != 0:
						diskpercent = int(server['disk']['total']['used']) / int(server['disk']['total']['avail'])
						if data['disk']['total']['status'] == 1: alert(server['hostname'], addr, 'Disk', 'Warning', diskpercent)
						elif data['disk']['total']['status'] == 2: alert(server['hostname'], addr, 'Disk', 'Critial', diskpercent)
					if data['uptime']['status'] != 0:
						if data['uptime']['status'] == 1: alert(server['hostname'], addr, 'Load', 'Warning', data['uptime']['load1'])
						elif data['uptime']['status'] == 2: alert(server['hostname'], addr, 'Load', 'Critical', data['uptime']['load1'])

					# This should be done on a timer, but if I do that, I have to use another thread, which more than doubles the memory usage.
					# So, instead, I'm going to do it whenever any other server updates.
					checkServers()

class Server(asyncore.dispatcher):
	def __init__(self, host, port):
		asyncore.dispatcher.__init__(self)
		self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
		self.bind(('', port))
		self.listen(1)
		
	def handle_accept(self):
		# when we get a client connection start a dispatcher for that
		# client
		global addr
		socket, addr = self.accept()
		logger.info('Connection by %s', (addr))
		Handler(socket)
			
class Handler(asyncore.dispatcher_with_send):
	# dispatcher_with_send extends the basic dispatcher to have an output
	# buffer that it writes whenever there's content

	def handle_read(self):
		info = self.recv(4096)
		logger.debug(info)
		if not info:
			self.close()
		else:
			processData(info)
def main():

	getConfig()
	dbConnect()
	
	TCP_IP = config['server']['listen_ip']
	TCP_PORT = int(config['server']['port'])

	global s
	s = Server(TCP_IP, TCP_PORT)
	asyncore.loop()

if __name__ == "__main__":

	signal.signal(signal.SIGTERM, sigHdl)
	signal.signal(signal.SIGHUP, sigHdl)
	signal.signal(signal.SIGINT, sigHdl)
	if debug == False:
		daemonize('/var/log/openstatus-server.log', '/var/log/openstatus-server.log', '/dev/null', '/var/run/openstatus-server.pid')
		main()
	elif debug == True:
		logger.info("OpenStatus started in debug mode with PID %s using config file %s" % (os.getpid(), configfile))
		main()
